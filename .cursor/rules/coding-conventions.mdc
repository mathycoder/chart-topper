---
description: Chart Topper coding conventions — tech stack, patterns, and what to avoid
alwaysApply: true
---

# Coding Conventions

## Tech Stack

- **Next.js 16** — App Router only (no Pages Router)
- **React 19** — functional components, hooks
- **TypeScript 5** — strict mode; avoid `any`; prefer types from `types/index.ts`
- **Tailwind CSS 4** — all styling via Tailwind classes; no CSS modules, no inline styles
- **`clsx` + `tailwind-merge`** — use `cn()` from `lib/utils.ts` for conditional/merged classes
- **`lucide-react`** — icons only from this library

## Project Structure

```
app/           Next.js App Router pages and API routes
components/    React components (shared/ for reused primitives)
hooks/         Custom React hooks — stateful logic lives here
lib/           Pure utility functions (gradeRange.ts, utils.ts)
types/         TypeScript types — extend here, don't redefine elsewhere
data/ranges/   Static range TypeScript files + index.ts registry
```

## Component Patterns

- Extract stateful logic into hooks in `hooks/`; keep components focused on rendering
- Responsive layout: desktop = two-column (controls left, grid right); mobile = single-column with fixed bottom action bar (`MobileActionBar`)
- Use `MobileDropdownBar` pattern for mobile controls
- Long-press interactions use 700ms threshold (see `usePainting` for reference)
- Drag/paint selection is a first-class interaction — don't break pointer event handling on `RangeChart` / `HandCell`

## State Management

- URL search params are the source of truth for navigation state (`position`, `stackSize`, `scenario`, `opponent`, `caller`) — managed via `useUrlState`
- No global state library (no Redux, Zustand, etc.) — use URL state + local `useState`/`useReducer`
- Range data is loaded synchronously via `getRange()` from `data/ranges/index.ts` — no `useEffect` data fetching for ranges

## Data Conventions

- Never add async loading for range data — it's static TypeScript
- To add a new range: create `data/ranges/{slug}.ts`, import it in `index.ts`, register in `RANGE_REGISTRY`
- `'black'` action = hand not in hero's range (not a real action choice — skip in grading/UI where appropriate)
- Builder Mode is dev-only; always keep it gated from production

## TypeScript

- Import shared types from `@/types`, not re-declared locally
- Use type guards from `types/index.ts`: `isSimpleAction()`, `isBlendType()`, `getBlendType()`, `getPrimaryAction()`
- `HandAction = SimpleAction | BlendedAction` — always handle both cases
- `QuizAction = SimpleAction | BlendType` — what the user submits in quiz

## Theming

- **Active themes**: `felt` (default) | `lounge` | `midnight` | `chalk` | `marker` | `classic`
- **Mechanism**: `data-theme` attribute on `<html>`. `felt` = no attribute; all others set `data-theme="<name>"`.
- **CSS variables**: All themeable colors are defined as CSS custom properties in `@theme` in `styles/globals.css`. Each non-default theme has a `[data-theme="<name>"]` override block in the same file that reassigns those variables.
- **Token names**: Use the semantic felt-palette tokens (`felt-bg`, `felt-surface`, `felt-elevated`, `felt-border`, `felt-muted`, `gold`, `gold-hover`, `cream`, `cream-muted`) and action tokens (`action-raise`, `action-call`, `action-fold`, `action-shove`, `action-black`) — never hardcode hex values in components.
- **`useTheme` hook** (`hooks/useTheme.ts`): manages theme state, applies `data-theme` to the DOM, persists to `localStorage`, and syncs a `?theme=` URL param. Call `setTheme(name)` to switch.
- **FOUC prevention**: A blocking inline `<script>` in `app/layout.tsx` `<head>` reads `?theme=` (then localStorage) and sets `data-theme` before first paint. Add any new theme name to the `valid` array in that script.
- **Adding a new theme**: (1) add a `[data-theme="<name>"]` block to `globals.css` overriding all tokens, (2) add `'<name>'` to the `Theme` union in `useTheme.ts`, (3) add it to the `isValid` check in `useTheme.ts`, (4) add it to the `valid` array in the blocking script in `layout.tsx`, (5) add an entry to `THEMES` in `NavDrawer.tsx`.
- **Cache**: Turbopack caches compiled CSS aggressively. After editing `globals.css`, run `npm run clean` (deletes `.next`) then restart the dev server to ensure the new theme CSS is compiled.
- **Light themes** (classic, chalk, marker): `--color-cream` maps to a dark foreground color and `--color-felt-*` surfaces map to whites/light greys — the token names are semantic, not literal.

## In an ideal world
- Look for DRY code opportunities, and maintain in components/shared

## What to Avoid

- CSS modules or `style={}` props for layout/color — use Tailwind
- `any` type — use proper types or generics
- Async data fetching for ranges — synchronous imports only
- Adding dependencies without a clear reason — the stack is intentionally lean
- Touching Builder mode without confirming dev-only intent
